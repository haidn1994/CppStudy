# 벡터(vector)?

벡터는 간단히 말하자면 인덱스로 접근할 수 있는 요소의 시퀀스이다.  
이름이 v인 vector를 예로 살펴보자. 벡터 v는 6개의 int타입 객체를 포함한다.  

```{.cpp}
vector<int> v = {5, 7, 9, 4, 6, 8}; // int 여섯 개를 포함하는 vector
```
v의 첫번째 요소의 인덱스는 0, 두 번째 요소의 인덱스는 1, ...이 되는 식이다.  
vector의 이름과 인덱스를 함께 지정해 요소를 참조할 수 있다.  


이제 위에서 본 벡터의 선언에 대해서 알아보자. 벡터를 만들려면 요소의 타입과 요소의 초기 값들을 지정한다.  
요소 타입은 vector 다음에 각진 괄호(<>)안에 지정하는데, 여기서는 타입을 int로 지정했다.  
이번에는 string을 지정하여 사용한 예제를 알아보자.  

```{cpp}
vector<string> philosopher
	= {"Kant", "Plato", "Hume", "Kierkegaard"};	// 문자열 4개를 포함하는 벡터
```

당연한 일이지만, 벡터에는 선언에서 지정했던 요소의 타입만 저장할 수 있다.  
(몰랐는데, 연산자 오버로딩([])으로 접근한 벡터 요소에도 =(대입 연산자)를 사용하는데 무리가 없는 듯 하다.)  

```{cpp}
philosopher[2] = 99; // 오류: int를 string에 대입
v[2] = "Hume";		 // 오류: string을 int에 대입
```
요소의 값은 지정하지 않고 vector의 크기만 지정할 수도 있다.  
이런 경우에는 (n)으로 표기하는데, 여기서 n이 바로 요소의 개수이며,  
요소의 값은 다음과 같이 타입별 기본 값으로 지정된다.  
```{cpp}
vector<int> vi(6);
vecotr<string> vs(4);
```

문자를 포함하지 않는 문자열 ""를 빈 문자열(empty string)이라고 한다.  
그리고 vector 안에 존재하지 않는 요소를 참조할 수 없다.  

```{cpp}
vi[20000] = 44; // 실행 시간 오류
```

실행 시간 오류와 첨자 연산(subscripting)에 대해서는 5장에서 살펴보자.

## vector 탐색

벡터의 각 요소에 접근하는 루프를 작성할 때는 다음 2가지 방법을 고려해 볼 수 있다.  

1. 전통적인 for루프를 사용 조건값으로는 v.size()를 사용한다.
2. for\_each literal을 사용한다.

하나씩 코드를 알아보자.
```{cpp}
vector<int> = {5, 7, 9, 4, 6, 8}; // int 여섯 개를 포함하는 vector

// for루프 -> 아래에서 보일 루프나 여기 루프나 구간 [0: v.size())을 탐색한다.
for(int i = 0; i < v.size(); i++)
	cout << v[i] << '\n';

// 향상된 for문 또는 for_each라고 한다.  
for(int x : v) // v에 포함된 각 x에 대해
	cout << v[i] << '\n';

```

## vector 크기 증가
처음에는 빈 vector로 시작해서 필요한 데이터를 읽거나 계산하면서 vector의 크기를 키워가는 경우가 있다.  
이럴 때 사용하는 핵심적인 연산이 바로 vector에 새로운 요소를 추가하는 push\_back이다.  

```{.cpp}
vector<double> v;	// v에 요소가 없는 빈 상태로 시작한다.
v.push_back(2.7);	// 값이 2.7인 요소를 마지막(back)에 추가 이제 v는 요소 한 개를 포함한다.
v.push_back(5.6);	// 값이 5.6인 요소를 마지막(back)에 추가 이제 v는 요소 두 개를 포함한다.
v.push_back(7.9);	// 값이 7.9인 요소를 마지막(back)에 추가 이제 v는 요소 세 개를 포함한다.
```

## 숫자를 이용한 예제

이제 좀 더 현실적인 예제를 살펴보자. 어떤 작업을 수행할 일련의 값을 프로그램 안으로 읽어 들일 때가 있다.  
여기서 '어떤 작업'이란 읽어 들인 값을 그래프로 그리거나, 평균과 중앙값을 계산하거나,  
가장 큰 값을 찾거나, 정렬하거나, 다른 데이터와 병합하거나, 필요한 값을 찾거나, 다른 데이터와 비교하는 등의 일을 포함한다.  
이처럼 데이터로 할 수 있는 계산의 종류에는 제한이 없지만, 무슨 계산을 하던 데이터를 컴퓨터의 메모리로 읽어들어야 한다.  
여기서는 알려지지 않은 크기의(크기가 클 수도 있는) 데이터를 컴퓨터로 읽어들이는 기본적 기술을 소개한다.  
손에 잡히는 예제로, 온도를 나타내는 부동소수점 숫자를 읽어 보자.  

```{.cpp}
// 온도를 벡터에 읽어 들인다.
int main()
{
	vector<double> temps;			// 온도를 저장할 벡터
	for(double temp; cin >> temp; )	// temp에 값을 읽는다.
		temp.push_back(temp);		// temp를 vector에 추가
}
```
이 코드는 무슨 일을 할까? 먼저 데이터를 저장할 vector를 선언한다.

>  vector<double> temps;			// 온도를 저장할 벡터

여기서 입력받을 타입을 지정했는데, double을 읽어서 저장한다.  
다음으로 실제 읽기를 수행하는 루프가 온다.  

>  for(double temp; cin >> temp; )  // temp에 값을 읽는다.
>      temp.push_back(temp			// temp를 vector에 추가한다.

값을 읽어들일 변수 temp를 double타입으로 선언했다.  
cin >> temp로 double을 읽은 후 읽어 온 double을 vector(의 마지막)에 추가한다.  
이들 각각의 연산은 앞에서 이미 살펴봤다.  
여기서 새로운 사실은 입력 연산 cin >> temp를 for구문의 조건으로 사용했다는 점이다.  
기본적으로 cin >> temp는 값을 올바로 읽으면 참, 그렇지 못하면 거짓이다.  
따라서 위와 같은 for구문은 입력받은 double을 모두 읽다가 잘못된 값을 입력받으면 종료한다.  
예를 들어 아래와 같이 입력해보자.  

> 1.2 3.4 5.6 7.8 9.0 |

temp에는 1.2, 3.4, 5.6, 7.8, 9.0의 다섯 개 요소가 차례대로 저장된다.  
문자 '|'는 입력을 종료하고자 사용했는데, double이 아닌 무엇이던 사용할 수 있다.  
10.6절에서 입력을 중단하는 방법과 입력 시의 오류 처리 방법을 살펴본다.  


그리고 입력 변수 temp의 유효 범위(scope)를 루프 안으로 제한하고자 다음과 같은 while구문이 아닌 for 구문을 사용했다.  
(여기서 알 수 있는 중요한 사실은 for문은 1줄만 써도 scope제한이 걸린다는 사실을 알 수 있다!)  
```{.cpp}
double temp;
while(cin >> temp)	// 입력
	temps.push_back(temp);	// vector에 추가
// .. 여기(while 밖)서도 temp를 사용할 수 있다.  
```
일반적으로 for구문의 동작을 맨 윗줄에서 알 수 있으므로, 코드를 더 읽기 쉽고 실수로 오류가 생길 가능성도 적다.  
데이터를 일단 vector에 넣고 나면 쉽게 조작할 수 있다. 예를 들어 온도의 평균과 중앙값을 계산해보자.  

```{.cpp}
// 온도의 평균과 중앙값을 계산한다.  
int main(void)
{
	vector<double> temps;			// 온도를 저장할 벡터
	for(double temp; cin >> temp; )	// temp에 값을 읽는다.
		temp.push_back(temp);		// temp를 vector에 추가

	// 온도의 평균 계산(덧셈에 대한 항등원)
	double sum = 0;
	// temps의 모든 인덱스 x에 대해 다음 작업을 시행하라
	for(int x : temps) sum += x;
	cout << "온도 평균 :" << sum/temps.size() << '\n';

	// 온도의 중앙값 계산(평균(mean)과 중앙값(median)은 모두 중심 성향이라는 점을 기억하라.)
	// 지금 여기에 나오는 중앙값 계산은 맞지만, 요소의 개수가 짝수라면 중앙값의 정의에 맞지 않는다.
	sort(temps); // 온도 정렬(해당 객체의 상태를 바꾼다는 점을 기억하라)
	cout << "온도 중앙값: " << temps[temps.size()/2] << '\n';
}
```

## 텍스트를 이용한 예제


```{.cpp}
```
```{.cpp}
```
```{.cpp}
```
```{.cpp}
```
