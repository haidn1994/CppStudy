# 프로그램은 문제로부터 시작한다.

프로그램을 작성하는 일은 문제로부터 시작한다. 즉, 프로그램을 바탕으로 해결에 도움을 줄 수 있는 문제가 필요하다.  
그리고 이러한 문제를 이해는 일이 좋은 프로그램으로 가는 지름길이다.  
프로그램을 아무리 우아하게 만들어도 엉뚱한 문제를 해결하는 프로그램이라면 결국엔 별 쓸모가 없다.  
전혀 의도치 않은 방향으로 프로그램을 활용하는 행복한 사고도 있긴 하지만, 그런 드문 행운에 의미하지는 말자.  
우리의 목적은 풀려고 마음먹은 문제를 프로그램을 이용해 간단하고 명료하게 해결하는 데 있다.  
지금 단계에서 우리에게 필요한 프로그램은 무엇일까?  

* 설계 기법과 프로그래밍 기법을 잘 반영하는 프로그램
* 프로그래머가 해야 할 의사 결정과 그에 필요한 고려사항을 잘 보여주는 프로그램
* 새로운 프로그래밍 언어 기능을 너무 많이 요구하지 않는 프로그램
* 설계에 대해 고민해볼 여지가 있을 정도로 복잡한 프로그램
* 문제 해결 방법에 있어 다양한 시도가 가능한 프로그램
* 쉽게 이해할 수 있는 문제를 다루는 프로그램
* 가치 있는 문제를 해결하는 프로그램
* 완벽하게 예시하고 이해할 수 있을 정도로 작은 해답을 지닌 프로그램

이런 기준에서 우리가 선택한 프로그램은 '입력받은 표현식에 포함된 일반적인 산술 연산을 컴퓨터로 처리하는 프로그램'으로,  
이후로는 간단한 계산기라고 칭한다. 이런 프로그램은 분명 유용하므로, 모든 데스크톱 컴퓨터가 이런 프로그램을 포함한다.  
그리고 이러한 프로그램만 구동할 용도로 특별히 제작된 '휴대용 계산기'라는 컴퓨터를 구입할 수도 있다.  


예를 들어 다음과 같이 입력하면

> 2+3.1\*4

프로그램의 응답은 다음과 같다.

> 14.4

불행히도 이 계산기 프로그램은 이미 우리 컴퓨터에 설치된 프로그램 이상의 일을 하지 못하지만,   
그런 기대는 처음 만드는 프로그램에서는 너무 과한 요구이다.  

## 문제 고찰
그래서 어떻게 시작하면 좋을까? 기본적으로는 문제를 곱씹어보고 어떻게 해결할지 생각해보자.  
우선 프로그램이 무슨 일을 해야 하며, 프로그램과 사용자가 어떻게 상호작용할지 따져보자.  
그런 다음에야 프로그램이 어떻게 원하는 일을 하게 할지 생각할 수 있다.  
다음으로 해결 방안을 간결하게 스케치한 후 첫 번째 아이디어에 어떤 문제가 있는지 살펴보자.  
문제와 그 해결방안을 친구와 토론해도 좋다.  
종이에 아이디어를 적은 방법보다 친구와 토론하는 방법이 아이디어의 틀린 점을 찾아내는데 특효다.  


6장과 7장에서 문제에 대한 부분적인 해답과 아이디어, 실수를 바탕으로 프로그램의 최종버전에 다다르는 방식이  
최종버전 그 자체만큼이나 중요하다는 사실을 명심하자.  
그리고 이러한 과정은 항상 접하는 언어의 기술적 세부 사항보다 더 중요하다(기술적 세부 사항은 자우에 다시 다룬다.)  
### 프로그램 개발의 단계

여기서는 프로그램 개발 단계의 용어들을 살펴본다. 주어진 문제를 해결하다 보면 결국 다음과 같은 단계를 반복하게 된다.  

#### 분석(analysis)

해야할 일을 명확히 하고,(명확하게 하지 않으면 **오류**의 원인이 된다!)  
그에 대해(현재 시점에서) 이해한 바를 설명하는 문서를 남긴다. 이러한 설명을 요구 사항이나 명세라고 한다.  
여기서는 요구 사항을 정리하고 문서로 작성하는 일에 대해 자세히 다루지는 않는다.  
이런 작업은 책의 범위를 벗어나지만, 해결할 문제의 규모가 커질수록 요구 사항 파악이 중요하다.  

#### 설계(design)

시스템의 전체적인 구조를 정하고, 구현에 어떤 부분이 포함돼야 하며, 각 부분은 어떻게 상호작용하는지 정한다.  
라이브러리를 비롯한 어떤 도구가 프로그램을 구조화 하는데 도움이 될 지 결정하는 일도 설계 고려 사항의 일부다.  

#### 구현(implementation)

코드를 작성하고 디버깅하고, 의도대로 동작하는지 테스트 한다.

### 전략

## 계산기로 복귀!

계산기와 어떻게 의사소통을 해야 할까?  
cin과 cout사용법은 알지만, 그래픽 사용자 인터페이스(GUI)를 다루니 아직은 키보드와 콘솔 창을 고집하자.  
다음과 같이 키보드에서 입력 받은 표현식을 계산하고 그 결과를 화면에 출력한다.  


표현식: 2+2  
결과: 4  
표현식: 2+2\*3  
결과: 8  
표현식: 2+3-25/5  
결과: 0  


위에서 2+2와 2+2\*3 같은 표현식을 제외한 나머지 부분은 프로그램이 만들어 낸 출력이다.  
표현식: 이라는 프롬프트를 사용자에게 출력하여 입력을 받는다.  
이렇게 사용 예를 미리 스케치 해보는 일은 중요하다.  
이를 바탕으로 프로그램이 해야 하는 최소한의 작업이 무엇인지 실용적으로 정의할 수 있다.  
설계와 분석 과정에서 이러한 사용 예를 유스케이스(use case)라고 한다.  
계산기가 해결해야 할 문제를 처음 접하면 사람들은 프로그램의 주요 논리를 다음과 같이 생각한다.  


read\_a\_line	// 한줄 입력
calculate		// 계산
write\_result	// 결과 출력


이렇게 명확하게 논리를 적어보는 것을 코드가 아니라 의사 코드(pseudo code)라고 한다.  
어떤 식으로 코드를 작성해야 할지 정확히 알 수 없는 설계 초기에 이런 방법을 사용한다.  
예를 들어 "계산한다"는 말은 함수 호출을 말하는가? 그렇다면 그 인자는 무엇인가?  
이런 질문에 답하기에 아직 이르다.  

### 첫번째 시도

이제 아주 간단한 계산기 프로그램을 작성해 보자.

```{.cpp}
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <vector>
using namespace std;

inline void keep_window_open() { char ch; cin >> ch; }

int main(void)
{
	cout << "표현식 (+와 -만 처리함): ";

	int lval = 0;
	int rval;
	char op;
	int result;
	cin >> lval >> op >> rval;	// 1 + 3과 같은 형식을 읽는다.

	if(op == '+')
		result = lval + rval;
	else if(op == '-')
		result = lval - rval;

	cout << "결과: " << result << '\n';
	keep_window_open();
	return 0;
}

```
이 프로그램은(생각보자) 잘 돌아간다. 이 프로그램이 완벽하지 않은 이유는 뭘까?  
어느 정도 잘 돌아가지 않는가! 하지만 곱셈과 나눗셈이 나온다면? 항이 여러개가 나온다면?  
너무 이른 성공에 도취하진 말자. 우선 다음과 같이 하자.

1. 우선 코드를 좀 정리한다.

2. 곱셈과 나눗셈을 추가한다.(예. 2\*3).

3. 한 개 이상의 피연산자를 처리할 수 있게 한다.(예, 1+2+3).

특히 입력이 적정한지 검사해야고, 많은 상수를 대상으로 이런 검사를 할 때는 if구문보다 switch구문이 더 좋다.  
또한 1+2+3+4처럼 여러 연산자를 연쇄(chaining)하려면 읽은 값을 거해 나가면 된다. 즉, 1로 시작해서 +2가 입력되면,  
1에 2를 더하고(중간 결과는 3), 다음에 +3이 입력되면 중간 결과(3)에 3을 더하는 식으로 **반복**한다.  
몇 차례의 시도를 거쳐 문법 오류와 논리 오류를 수정한 후에 다음과 같은 프로그램을 만들 수 있다.  

```{.cpp}
#include "../../include/std_lib_facilities.h"

int main(void)
{
	cout << "표현식 입력(+, -, *, / 처리함)\n";
	cout << "표현식의 끝에 x를 입력(예, 1+2*3x): ";

	int lval = 0;
	int rval;
	cin >> lval;	// 가장 왼쪽 피연산자 입력
	if(!cin) error("첫 번째 피연산자 없음");
	
	for(char op; cin >> op; ){
		if(op != 'x') cin >> rval;
		if(!cin) error("두 번째 피연산자가 없다.");

		switch(op){
		case '+':
			lval += rval;
			break;
		case '-':
			lval -= rval;
			break;
		case '*':
			lval *= rval;
			break;
		case '/':
			lval /= rval;
			break;
		default:
			cout << "결과:" << lval << '\n';
			keep_window_open();
			return 0;
		}
	}
	error("잘못된 표현식");
}

```

이 프로그램은 나쁘지 않으나, 1+2\*3을 입력하면 수학 선생님이 가르쳐준 정답인 7이 아니라 9를 출력한다.  
마찬가지로 1-2\*3의 결과는 우리가 기대하는 -5가 아니라 (1+2)\*3으로 계산했다.  
수학의 원칙을 부술수는 없는 노릇이다. 고칠 방법을 생각해 보자.  

### 토큰

결국 한 행 안에 \*(나 /)가 있는지를 미리 봐야 한다.(Look ahead).  
이렇게 하려면 단순히 왼쪽에서 오른쪽으로 계산하는 순서를 탈피해야 한다.  
불행히도 여기서 더 나가려면 몇 가지 문제가 생긴다.

#### 문제 1.

표현식을 꼭 한줄로 입력 받을 필요는 없다. 예를 들어,
1  
+  
2  
이렇게 입력해도 지금까지의 코드에서는 잘 동작한다.  

#### 문제 2.

여러 줄에 걸친 입력에 포함된 숫자와 더하기 부호, 빼기 부호, 괄호 사이에서 \*(나 /)를 **어떻게** 찾는가?  

#### 문제 3.

\*가 어디에 있었는지 어떻게 기억하는가?  

#### 문제 4.

엄격하게 왼쪽에서 오른쪽으로 계산하는 순서가 아니면 어떻게 처리하는가? (예: 1+2\*3)  


일단 1~3번 문제는 그나마 해결하기 쉬워보인다. 따라서 4번 문제는 나중에 살펴보고,  
약간의 도움을 받자. 누군가는 분명히 입력으로부터 숫자와 연산자를 읽고,  
살펴보기 쉬운 방식으로 저장하는 관례적인 방법을 알고 있을 것이다.  
여기서 말하는 관례적이고 매우 유용한 해법이 바로 "토큰화(Tokenize)"다. 즉, 입력 문자열을 읽고 토큰(token)으로 조립한다.  
다음과 같은 입력을 보자.

> 45+11.5.7

프로그램이 만들어낸 토큰 목록은 다음과 같다.  

* 45 
* +
* 11.5
* /
* 7

토큰이란 숫자나 연산자를 비롯해서 우리가 한 단위(unit)로 생각하는 무언가를 나타내는 문자열이다.  
C++ 컴파일러도 소스코드를 이런 식으로 다룬다. 사실 토큰화는 대부분의 텍스트 분석에서 기초가 된다.  
C++ 표현식을 처리하려면 세 종류의 토큰이 필요하다.  

* 부동소수점 리터럴: 예를 들어 3.14와 0.274e2, 42처럼 C++에서 정의된 형식

* 연산자: 예, +, -, \*, /, %

* 괄호: (, )


### 토큰 구현

프로그램에서 토큰을 어떻게 표현할 수 있을까? 다른 말로 하면 여러분은 Token타입이 어떤 모습이길 바라는가?  
Token은 분명 +와 -등의 연산자와, 42와 3.24등의 숫자 값을 표현할 수 있어야 한다.  
따라서 토큰의 종류(Kind)를 나타내는 무언가와, 그 안에 저장된 숫자 값(value)을 포함해야 한다.  
C++에서 이런 아이디어를 표현하는 방법은 여러 가지가 있지만, 우리에게 유용한 가장 간단한 방법은 다음과 같다.  

```{.cpp}
class Token{ // 아주 간단한 사용자 정의 타입
public:
	char kind;
	double value;
};
```
Token은 일종의 타입(int나 char같은)으로 변수를 정의하거나 값을 저장할 때 쓸 수 있으며,  
(멤버라고 부르는)kind와 value 두 부분으로 이뤄진다. class키워드는 '사용자 정의 타입'을 의미하며,  
0개 이상의 멤버를 포함하는 타입을 정의한다. 여기서 첫 번째 멤버는 문자 char형식의 kind로, 단순히 +와 \*를 나타내는  
'+'와 '\*'를 저장할 수 있다. 이 타입을 생성하는 방법은 다음과 같다.  

```{.cpp}
Token t;		// t는 Token
t.kind = '+';	// t는 +를 나타낸다.

Token t2;		// t2는 다른 Token
t2.kind = '8';	// '8'은 토큰의 종류가 숫자임을 나타낸다.
t2.value = 3.14;

// 't의 kind'로, t2.value는 't2의 value'로 읽을 수 있다.  
// 그리고 int를 복사하듯이 Token도 복사할 수 있다.  

Token tt = t;	// 복사 초기화
if(tt.kind != t.kind) error("불가능함!");
t = t2;			// 대입
cout << t.value // 3.14를 출력한다.
```

Token은 C++ 사용자 정의 타입의 한 예이며, 사용자 정의 타입은 멤버 함수(연산자)와 데이터 멤버를 포함핳 수 있다.  
하지만 Token에서는 간단한 사용자 정의 타입의 멤버를 읽고 쓸 수 있도록 기본적으로 제공되는 방법을 사용하므로,  
따로 멤버 함수를 정의하지 않는다.  

```{.cpp}
class Token{
public:
	char kind;		// 토큰의 종류
	double value;	// 종류가 숫자인 경우의 값
};

// 이제 다음과 같이 Token을 초기화(생성)할 수 있다.

Token t1 {'+'};			// t1.kind = '+'가 되도록 t1을 초기화
Token t2 {'8', 11.5};	// t2.kind = '8'이고 t2.value = 11.5가 되도록 t2를 초기화

```

클래스 객체 초기화에 관한 내용은 9장을 참고하라.

### 토큰 사용

이제 계산기를 완성할 수 있을 지도 모른다! 그러나 그 전에 약간의 계획을 세울 필요가 있다.  
계산기 프로그램에서 Token을 어떻게 사용할까? 다음과 같이 Token의 vector에 입력을 받아올 수 있다.  

```{.cpp}
Token get_token();	// cin에서 토큰을 읽는 함수

vector<Token> tokens;	// 여기에 토큰을 저장할 수 있다.
int main()
{
	while(cin){
		Token t = get_token();
		tokens.push_back(t);
	}
	// ...
}
```
이제 표현식을 먼저 읽어두고(벡터에 먼저 담아두고) 나중에 계산할 수 있다.  
이렇게 해 놓으면 숫자 11과 12가 문자열이 아닌 숫자 값으로 저장돼 있으므로 곱셈을 쉽게 수행할 수 있다.  
이제 더 복잡한 표현식을 살펴보자. 표현식이 1+2\*3이라면 tokens는 다음과 같은 Token 다섯개를 포함한다.  

| '8' | '+' | '8' | '\*' | '8' |
|-----|-----|-----|-----|-----|
| 1   |     | 2   |     | 3   |

드디어 단순히 루프를 돌아서 곱셈 연산을 찾을 수 있게 됐다!

```{.cpp}
for(int i = 0; i < tokens.size(); ++i){
	if(tokens[i].kind == '*'){	// 곱셈을 찾았다!
		double d = tokens[i-1].value * tokens[i+1].value;
		// 그 다음엔 무슨 일을 할까?
	}
}
```

하지만 실제로 소스코드를 컴파일하고 곱셈식이 들어간 입력을 주어 실행하면 우리가 바라던 값은 나오지 않는다.  
여기서 잠시 프로그래밍을 멈추고, 입력 문자열을 어떻게 읽고 이애한 후 산술 표현식으로 계산해야 하는지 생각해보자.  

### 칠판으로 돌아가자

## 문법

* 부동소수점 리터럴

* 연산자

* 괄호

#### 숫자 2 파싱

#### 표현식 2+3 파싱

#### 표현식 45+11.5\*7 파싱

#### 간단한 영어 문장 파싱



