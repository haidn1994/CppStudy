# 유용한 벡터

벡터는 C++표준 라이브러리에서 가장 유용한 컨테이너다. 벡터는 주어진 타입의 요소로 구성된 시퀀스를 제공한다.  
인덱스(첨자:subscript)로 그 요소 중 하나를 참조하고, push\_back()으로 벡터를 확장하고, size()로 벡터에 저장된 요소의 개수를 조회하고  
vector의 요소에 접근할 때마다 구간 밖의(out-of-range) 요소에 접근하는지 확인 할 수 있다.  
표준 라이브러리의 벡터는 편리하고, 유연하고, (시간과 공간적인 측면에서)효율적이며, 각 요소에 대한 정적인 타입 안정성을 제공하는 컨테이너이다.  
표준 String도 비슷한 성질을 띠며, list와 map같은 그 밖의 유용한 표준 컨테이너도 마찬가지인데, 20장에서 살펴볼 예정이다.  


그러나 컴퓨터의 메모리는 이처럼 유용한 타입을 직접적으로 지원하지 않는다.  
하드웨어는 그저 일련의 바이트를 직접적으로 다룰 뿐이다.  
가장 낮은 수준에서 보자면 컴퓨터는 push\_back() 같이 복잡한 것은 전혀 알지 못한다.  
컴퓨터는 적은 수의 바이트를 한 번에 읽고 쓸 뿐이다.  


17장과 이어지는 두개의 장에서 모든 프로그래머가 사용할 수 있는 기본적인 언어 기능을 이용해서 벡터를 만드는 방법을 살펴본다.  
이를 바탕으로 유용한 개념과 프로그래밍 기법을 설명하고, 그것들을 C++언어 기능을 활용해서 표현하는 방법을 학습한다.  
이처럼 벡터 구현과정에서 맞닥뜨리는 언어 기능과 프로그래밍 기법은 일반적으로 유용하고 광범위하게 적용 할 수 있다.  


벡터의 설계와 구현, 용법을 학습한 후에는 map을 비롯한 다른 컨테이너와 C++표준 라이브러리가 제공하는 그 밖의 우아하고 효율적인 기능의 활용법을 배운다.  
알고리즘이라고 부르는 이러한 기능을 바탕으로 데이터를 처리하는 등의 일반적인 작업을 우리 스스로 프로그래밍 하는 수고를 덜 수 있다.  
모든 C++ 구현테에 포함된 이런 기능을 이용하면 우리의 라이브러리를 작성하고 테스트하는 일을 쉽게 할 수 있다.  
앞에서 이미 표준 라이브러리의 가장 유용한 알고리즘 중 하나인 sort()를 사용한 적이 있다.  


점점 더 정교한 벡터 구현체를 만들어 가는 과정을 바탕으로 벡터를 알아보겠다.  
처음에는 매우 간단한 벡터를 만든다. 그리고 만들어진 벡터에서 발생하는 문제점을 찾아 수행한다.  
이 과정을 몇 번 반복하면 오늘날 C++컴파일러에 탑재돼 우리가 앞에서 줄곧 사용했던 표준 라이브러리 벡터와 대체적으로 유사한 구현체를 만들수 있다.  
이 과정에서 메모리 사용과 자료구조에 관련된 여러 고전적인 문제를 살펴볼 수 있다.  
앞으로의 학습 계획은 다음과 같다.  

* 17장 
변화하는 메모리 필요량을 어떻게 다루는가? 특히 서로 다른 벡터는 어떻게 각각 다른 개수의 요소를 저장하며,  
한 벡터는 어떻게 시간에 따라 요소의 개수를 달리하는가?  
이 문제를 해결하는 데 자유 저장 영역(힙 영역:heap storage)과 포인터, 캐스트(멸시적 타입 변환), 참조가 필요하다.  

* 18장
벡터를 어떻게 복사하는가? 첨자 연산을 어떻게 제공하는가? 배열은 무엇이고, 배열과 포인터는 어떤 관계인가?  

* 19장
여러 가지 타입의 요소를 위한 벡터는 어떻게 만드는가? 구간 오류는 어떻게 처리하는가?  
그 해답으로 C++템플릿과 예외를 살펴본다.  

## 벡터의 기본

매우 간단한 활용 예를 바탕으로 벡터의 점진적 설계를 시작하자.  

```{.cpp}
vector<double> age(4);	// double 타입의 요소 네 개를 포함하는 벡터
age[0] = 0.33;
age[1] = 22.0;
age[2] = 27.2;
age[3] = 54.2;
```

이 코드는 double타입의 요소 4개를 포함하는 벡터를 생성하며, 각 요소의 값은 0.33과 22.0, 27.2, 54.3다.  
이 네 요소의 번호는 0, 1, 2, 3인데, 이처럼 C++ 표준 라이브러리 컨테이너의 번호는 항상 0부터 시작한다.  
0부터 번호 매기기는 매우 일반적이며, C++프로그래머 사이에서 널리 통용된다.  
벡터에 포함된 요소의 개수를 그 벡터의 크기(size)라고 한다. 예제의 벡터 크기는 4다.  
vector의 요소는 0부터 크기-1까지 수로 번호를 매긴다.(인덱싱한다.)  
예를 들어 age에 포함된 요소는 0부터 age.size()-1까지의 번호에 대응한다.  


이런 **설계**를 어떨게 컴퓨터의 메모리에 실체화 할 수 있을까?  
어떻게 하면 이런 방식으로 값을 저장하고 접근할 수 있는가? 당연한 말이지만 그 해답은 클래스로 정의해야 하며, 
그 클래스가 바로 **벡터**다. 더 나아가 그 크기를 저장할 데이터 멤버와 각 요소를 저장할 데이터 멤버가 필요하다.  
하지만 요소의 개수가 변하는 상황에서 요소의 집합을 어떻게 정의한단 말인가?  
이럴 때 사용하는게 바로 벡터이지만, 이런 말은 모순이 된다. 지금 우리가 정의하는 클래스가 바로 벡터이기 때문이다.  


이제 간단한 구현을 통해 학습해보자.
```{.cpp}
class vector{
	int size, age0, age1, age2, age3;
	//...
};
```
문법적인 세부 사항을 무시하면 이 코드는 다음 표를 참고하면 이해하기 쉽다.

|       |   age:  |         |         |         |
|:-----:|:-------:|:-------:|:-------:|:-------:|
| size: | age[0]: | age[1]: | age[2]: | age[3]: |
|   4   |   0.33  |   22.0  |   27.2  |   54.2  |

간단하고 멋져 보이지만 push\_back으로 요소를 추가하려는 순간 우리는 좌절하게 된다.  
요소의 개수가 프로그램 코드 안에 4개로 고정되어 있어서 요소를 추가할 수 없기 때문이다.  
고정된 개수의 요소를 저장하는 저장하는 자료 구조 이상의 무엇이 필요하다.  
push\_back()처럼 벡터에 포함된 요소의 개수를 변화시키는 연산은 고정된 요소 개수로 정의된 벡터에서 구현할 수 없다.  
기본적인 방법을 살펴보자면 요소의 집합을 가리키는 데이터 멤버를 이용해서 더 큰 공간이 필요할 때  
그 멤버가 다른 요소의 집합을 가리키게 하면 된다. 따라서 첫 번째 요소의 메모리 주소와 비슷한 역할의 뭔가가 필요한데,  
C++에서는 이처럼 메모리 주소를 저장하는 타입을 포인터라고 하며, C에서 배웠으니 자세한 설명은 생략한다.  
위에서 언급한 내용을 적용하면 벡터 클래스의 첫 번째 버전을 다음과 같이 정의 할 수 있다.  

```{.cpp}
// (vector<double>와 유사한) 매우 단순화된 double타입 벡터
class vector{
	int sz;			// 크기
	double *elem;	// 첫번째 요소를 가리키는 (double 타입의)포인터
public:
	vector(int s);	// 생성자: s개의 double 할당
					// elem이 할당된 요소 집합을 가리키게 하고
					// sz에 s를 대입한다.
	int size() const { return sz; }	// 현재 크기
```

벡터의 설계를 다루기 전에 포인터의 개념을 더 깊이 이해하자.  
포인터와 배열 간의 밀접한 관계를 이해하는 일은 C++ 메모리 표현을 이해하는 데 핵심이 된다.  

## 메모리와 주소, 포인터

컴퓨터의 메모리는 일련의 바이트이며, 각 바이트에 0부터 시작하는 번호를 매길 수 있다.  

