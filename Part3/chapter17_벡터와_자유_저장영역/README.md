# 유용한 벡터

벡터는 C++표준 라이브러리에서 가장 유용한 컨테이너다. 벡터는 주어진 타입의 요소로 구성된 시퀀스를 제공한다.  
인덱스(첨자:subscript)로 그 요소 중 하나를 참조하고, push\_back()으로 벡터를 확장하고, size()로 벡터에 저장된 요소의 개수를 조회하고  
vector의 요소에 접근할 때마다 구간 밖의(out-of-range) 요소에 접근하는지 확인 할 수 있다.  
표준 라이브러리의 벡터는 편리하고, 유연하고, (시간과 공간적인 측면에서)효율적이며, 각 요소에 대한 정적인 타입 안정성을 제공하는 컨테이너이다.  
표준 String도 비슷한 성질을 띠며, list와 map같은 그 밖의 유용한 표준 컨테이너도 마찬가지인데, 20장에서 살펴볼 예정이다.  


그러나 컴퓨터의 메모리는 이처럼 유용한 타입을 직접적으로 지원하지 않는다.  
하드웨어는 그저 일련의 바이트를 직접적으로 다룰 뿐이다.  
가장 낮은 수준에서 보자면 컴퓨터는 push\_back() 같이 복잡한 것은 전혀 알지 못한다.  
컴퓨터는 적은 수의 바이트를 한 번에 읽고 쓸 뿐이다.  


17장과 이어지는 두개의 장에서 모든 프로그래머가 사용할 수 있는 기본적인 언어 기능을 이용해서 벡터를 만드는 방법을 살펴본다.  
이를 바탕으로 유용한 개념과 프로그래밍 기법을 설명하고, 그것들을 C++언어 기능을 활용해서 표현하는 방법을 학습한다.  
이처럼 벡터 구현과정에서 맞닥뜨리는 언어 기능과 프로그래밍 기법은 일반적으로 유용하고 광범위하게 적용 할 수 있다.  


벡터의 설계와 구현, 용법을 학습한 후에는 map을 비롯한 다른 컨테이너와 C++표준 라이브러리가 제공하는 그 밖의 우아하고 효율적인 기능의 활용법을 배운다.  
알고리즘이라고 부르는 이러한 기능을 바탕으로 데이터를 처리하는 등의 일반적인 작업을 우리 스스로 프로그래밍 하는 수고를 덜 수 있다.  
모든 C++ 구현테에 포함된 이런 기능을 이용하면 우리의 라이브러리를 작성하고 테스트하는 일을 쉽게 할 수 있다.  
앞에서 이미 표준 라이브러리의 가장 유용한 알고리즘 중 하나인 sort()를 사용한 적이 있다.  


점점 더 정교한 벡터 구현체를 만들어 가는 과정을 바탕으로 벡터를 알아보겠다.  
처음에는 매우 간단한 벡터를 만든다. 그리고 만들어진 벡터에서 발생하는 문제점을 찾아 수행한다.  
이 과정을 몇 번 반복하면 오늘날 C++컴파일러에 탑재돼 우리가 앞에서 줄곧 사용했던 표준 라이브러리 벡터와 대체적으로 유사한 구현체를 만들수 있다.  
이 과정에서 메모리 사용과 자료구조에 관련된 여러 고전적인 문제를 살펴볼 수 있다.  
앞으로의 학습 계획은 다음과 같다.  

* 17장 
변화하는 메모리 필요량을 어떻게 다루는가? 특히 서로 다른 벡터는 어떻게 각각 다른 개수의 요소를 저장하며,  
한 벡터는 어떻게 시간에 따라 요소의 개수를 달리하는가?  
이 문제를 해결하는 데 자유 저장 영역(힙 영역:heap storage)과 포인터, 캐스트(멸시적 타입 변환), 참조가 필요하다.  

* 18장
벡터를 어떻게 복사하는가? 첨자 연산을 어떻게 제공하는가? 배열은 무엇이고, 배열과 포인터는 어떤 관계인가?  

* 19장
여러 가지 타입의 요소를 위한 벡터는 어떻게 만드는가? 구간 오류는 어떻게 처리하는가?  
그 해답으로 C++템플릿과 예외를 살펴본다.  
